데이터 전처리 과정에서 문자형 벡터 또는 문자열에서 원하는 텍스트를 찾고, 바꾸고, 합치고, 나누는 과정이 필요한 경우가 많습니다. 이번 포스팅에서는 텍스트를 원하는 방식으로 처리하는 함수들을 소개하고자 합니다. R 기본함수들로도 충분히 가능한 작업이지만 이번 포스팅에서는 **stringr**의 주요 함수들을 소개하려고 하는데요. 그 이유는 R 기본함수들로는 `파이프 연산자(%>%)`를 사용하지 못하는 경우가 많기 때문입니다. 파이프 연산자를 사용하면 코드를 깔끔하게 정리할 수 있고 가독성도 좋아집니다. 따라서 아래에 관련 함수에 대한 예제에서는 의도적으로 파이프 연산자를 사용하도록 하겠습니다.

참고로 파이프 연산자는 앞에서 실행된 결과를 다음 함수의 첫 번째 인자로 자동할당해주는 기능을 합니다. 코드로 예를 들면 쉽게 이해할 수 있습니다. 아래 두 줄의 코드는 같은 결과를 출력합니다.

``` r
# 필요 패키지를 불러옵니다. 
library(dplyr)
library(stringr)

# 파이프 연산자를 사용하지 않는 경우
str_detect(string = letters[1:5], pattern = 'e')
```

    ## [1] FALSE FALSE FALSE FALSE  TRUE

``` r
# 파이프 연산자를 사용하는 경우
letters[1:5] %>% str_detect(pattern = 'e')
```

    ## [1] FALSE FALSE FALSE FALSE  TRUE

파이프 연산자를 사용하지 않으면 파이프 연산자를 사용하는 경우보다 대체르 코드의 길이가 더 깁니다. 때에 따라서는 (불필요하지만) 중간 과정의 객체를 만들어야 하기도 하고, 무엇보다 함수 인자에 할당되는 값을 해석하기 위해 (마치 영어를 한글로 번역하듯이) 안에서부터 바깥으로 나오면서 이해해야 하는 경우도 많습니다.

그러나 파이프 연산자를 사용하면 왼쪽에서 오른쪽으로, 위에서 아래로 이동하면서 순차적으로 실행되기 때문에 이해하기 편하고, 코드를 깔끔하게 정리할 수 있는 것입니다. 위에서 두 번째 코드를 보면 파이프 연산자 뒤에 오는 `str_detect()` 함수의 첫 번째 인자인 `string`을 따로 명시하지 않아도 파이프 연산자 왼쪽에 있는 `letters[1:5]`가 자동으로 할당됩니다.

파이프 연산자에 대한 재미있는 예시를 하나 들고 본론으로 넘어가겠습니다.

``` r
# 평균이 0이고 표준편차가 1인 임의의 수를 100개 만들어 x에 할당합니다. 
set.seed(seed = 123)
x <- rnorm(n = 100, mean = 0, sd = 1)

# x의 평균을 구하고 제곱을 한 뒤, 
# 소수점 4째자리까지 보이도록 반올림하는 코드를 작성해보겠습니다. 

# 파이프 연산자를 사용하지 않는 경우
round(x = mean(x)^2, digits = 4L)
```

    ## [1] 0.0082

``` r
# 파이프 연산자를 사용하는 경우
x %>% 
  mean() %>% 
  .^2 %>% 
  round(digits = 4L)
```

    ## [1] 0.0082

제가 보기에는 파이프 연산자를 쓴 코드가 더 예쁘고 보기 좋은데 여러분은 어떤가요? ^^

### 관심 있는 패턴 포함 여부 확인하기

`str_detect()` 함수 `string` 인자에 문자형 벡터를 할당하고 `pattern` 인자에 관심 있는 텍스트를 할당한 후 실행하면, 문자형 벡터의 각 원소 중 관심 있는 텍스트를 포함하면 `TRUE`, 그렇지 않으면 `FALSE`를 출력합니다. 만약 `string` 인자에 문자열을 할당하면, 해당 문자열에 관심 있는 텍스트가 포함되어 있는지를 `TRUE` 또는 `FALSE`로 출력합니다. 실습을 위해 샘플 문자형 벡터를 하나 생성한 뒤, `str_detect()` 함수를 실행합니다.

``` r
# 샘플 문자형 벡터를 생성합니다. 
subject <- c('국어', '영어', '수학', '과학', '국사', '도덕', '음악', '미술', '체육')

# 벡터에서 '어'를 포함하는 원소(과목명) 포함 여부를 확인합니다. 
subject %>% str_detect(pattern = '어')
```

    ## [1]  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE

전체 원소 중 '어'를 포함하고 있으면 `TRUE`, 없으면 `FALSE`로 출력된 것을 확인할 수있습니다. 이 코드 뒤에 `파이프 연산자(%>%)`와 `which()`를 추가하면 `TRUE`에 해당하는 원소의 위치를 숫자로 출력합니다. 이것은 R 기본 함수인 `grep()` 함수와 같은 결과를 갖습니다.

``` r
# 벡터에서 '어'를 포함하는 원소(과목명)의 위치를 숫자로 출력합니다.
subject %>% str_detect(pattern = '어') %>% which()
```

    ## [1] 1 2

``` r
grep(pattern = '어', x = subject)
```

    ## [1] 1 2

### 관심 있는 패턴 출력

`str_subset()` 함수 `string` 인자에 문자형 벡터를 할당하고 `pattern` 인자에 관심 있는 텍스트를 할당한 후 실행하면, 문자형 벡터에서 관심 있는 텍스트를 포함하는 원소만 출력합니다. `grep()` 함수에 `value = TRUE`를 추가하면 위치가 아닌 해당 원소값을 출력합니다.

``` r
# 벡터에서 '어'를 포함하는 원소(과목명)을 출력합니다.
subject %>% str_subset(pattern = '어')
```

    ## [1] "국어" "영어"

``` r
grep(pattern = '어', x = subject, value = TRUE)
```

    ## [1] "국어" "영어"

이번에는 관심 있는 텍스트를 찾는 다른 방법을 소개합니다. `str_extract()` 함수는 `string` 인자에 할당된 문자형 벡터의 각 원소에 대해서 관심 있는 텍스트가 있으면 정확히 그 패턴을, 없으면 `NA`를 출력합니다. 결과 객체는 벡터입니다.

``` r
# 샘플 문자형 벡터를 생성합니다. 
object <- c('요거트', '요요', '요리', '오리')

# 벡터의 각 원소에서 '요'를 포함하면 '요'를 출력합니다. 없으면 NA를 출력합니다. 
object %>% str_extract(pattern = '요')
```

    ## [1] "요" "요" "요" NA

그런데 주어진 문자형 벡터에서 두 번째 원소인 `요요`는 관심 있는 텍스트를 두 개 이상 가지고 있습니다. 이와 같이 관심 있는 텍스트가 2개 이상인 문자열에 대해서 모든 텍스트를 출력하고자 할 때 `str_extract_all()` 함수를 이용하면 됩니다. 다만 이 함수는 결과 객체를 리스트로 반환한다는 점에 주의해야 합니다.

``` r
# 벡터의 각 원소에서 '요'를 모두 찾아 출력합니다. 없으면 NA를 출력합니다. 
object %>% str_extract_all(pattern = '요')
```

    ## [[1]]
    ## [1] "요"
    ## 
    ## [[2]]
    ## [1] "요" "요"
    ## 
    ## [[3]]
    ## [1] "요"
    ## 
    ## [[4]]
    ## character(0)

실행 결과 리스트의 두 번째 원소가 `요`를 두 개 갖는 벡터인 것을 확인할 수 있습니다.

### 관심 있는 패턴을 다른 패턴으로 바꾸기

`str_replace()` 함수 `string` 인자에 문자형 벡터, `pattern` 인자에 찾고자 하는 텍스트, `replacement` 인자에 바꿀 텍스트를 각각 할당한 후 실행하면, 문자형 벡터 각 원소에 대하여 찾고자 하는 텍스트를 바꿀 텍스트로 변경하여 벡터로 출력합니다.

``` r
# 벡터의 각 원소에 있는 '요'를 '유'로 바꿉니다. 
# '요'가 두 번 이상 있어도 맨 처음 '요'만 '유'로 바꿉니다. 
object %>% str_replace(pattern = '요', replacement = '유')
```

    ## [1] "유거트" "유요"   "유리"   "오리"

다만 이렇게 하면 찾고자 하는 텍스트가 여러번 반복될 때 맨 처음 텍스트만 바꿔줍니다. 만약 모든 텍스트를 다 바꿔주고 싶다면 `str_replace_all()` 함수를 사용하면 됩니다. 이것은 R 기본함수인 `gsub()`와 같은 결과를 갖습니다.

``` r
# 벡터의 각 원소에 있는 모든 '요'를 '유'로 바꿉니다. 
object %>% str_replace_all(pattern = '요', replacement = '유')
```

    ## [1] "유거트" "유유"   "유리"   "오리"

``` r
gsub(pattern = '요', replacement = '유', x = object)
```

    ## [1] "유거트" "유유"   "유리"   "오리"

### 여러 문자열을 (구분자를 추가하여) 하나의 문자열로 합치기

`str_c()` 함수에 여러 문자열을 콤마(,)로 구분하여 할당한 후 실행하면, 여러 문자열이 하나의 커다란 문자열로 합쳐집니다. 이 함수의 `c`는 `combine` 또는 `concatenate`의 머릿글자로 이해하시면 됩니다.

``` r
# 여러 문자열을 하나의 문자열로 합칩니다.
str_c('가', '나', '다', '라', '마', '바', '사')
```

    ## [1] "가나다라마바사"

만약 문자열 사이에 특정 구분자(seperator)를 추가하려면, `str_c()` 함수에 `sep = '구분자'`를 추가하면 됩니다. 이것은 R 기본함수 `paste()`에 `sep = '구분자'`를 추가한 것과 같은 결과를 갖습니다.

``` r
# 여러 문자열에 구분자를 추가하여 하나의 문자열로 합칩니다.
str_c('가', '나', '다', '라', '마', '바', '사', sep = '+')
```

    ## [1] "가+나+다+라+마+바+사"

``` r
paste('가', '나', '다', '라', '마', '바', '사', sep = '+')
```

    ## [1] "가+나+다+라+마+바+사"

만약 `paste()`에 `sep` 인자를 추가하지 않고 실행하면 어떻게 될까요?

``` r
# paste 함수에 sep 인자를 추가하지 않고 실행하면 공백이 구분자로 추가됩니다. 
paste('가', '나', '다', '라', '마', '바', '사')
```

    ## [1] "가 나 다 라 마 바 사"

모든 문자열 사이에 공백이 하나씩 추가된 것을 알 수 있습니다. 즉, `paste()` 함수는 `sep = " "`이 기본값으로 설정되어 있습니다. 따라서 `str_c()`에 `sep`를 추가하지 않은 것과 동일한 결과를 얻으려면, `paste()` 함수에 `sep = ""`를 추가해주거나 아니면 `paste0()`를 사용하면 됩니다.

``` r
# paste 함수 sep 인자에 ''를 할당하고 실행하면
# 공백 없이 하나의 문자열로 합쳐집니다.
paste('가', '나', '다', '라', '마', '바', '사', sep = '')
```

    ## [1] "가나다라마바사"

``` r
paste0('가', '나', '다', '라', '마', '바', '사')
```

    ## [1] "가나다라마바사"

이번에는 `str_c()` 함수에 여러 문자열 대신 문자형 벡터를 할당하고 `sep = '  구분자'`를 추가한 후 실행해보겠습니다.

``` r
# str_c 함수에 문자형 벡터를 할당하고 실행하면 원하는 결과를 얻을 수 없습니다. 
krletters <- c('가', '나', '다', '라', '마', '바', '사')
krletters %>% str_c(sep = '+')
```

    ## [1] "가" "나" "다" "라" "마" "바" "사"

원래 문자형 벡터와 동일한 결과를 출력할 뿐, 하나의 문자열로 합쳐지지 않았습니다. 문자형 벡터의 각 원소를 하나의 커다란 문자열로 합치려면 `sep` 대신 `collapse` 인자를 사용하여야 합니다. 이것은 `paste()` 함수에도 동일하게 적용됩니다.

``` r
# 문자형 벡터의 각 원소를 하나의 커다란 문자열로 합칠 때에는
# collapse 인자를 사용합니다. 
krletters %>% str_c(collapse = '+')
```

    ## [1] "가+나+다+라+마+바+사"

``` r
paste(krletters, collapse = '+')
```

    ## [1] "가+나+다+라+마+바+사"

### 하나의 문자열을 구분자로 분리하기

`str_split()` 함수 `string` 인자에 문자열을 할당하고 `pattern` 인자에 구분자를 할당한 후 실행하며, 문자열을 구분자 기준으로 나눈 후 리스트 객체를 반환합니다. 이것은 R 기본함수인 `strsplit()`와 동일한 결과를 갖습니다.

``` r
# 하나의 커다란 문자열을 생성합니다. 
krletters2 <- krletters %>% str_c(collapse = '+')

# 문자열을 구분자(+) 기준으로 분리합니다. 
krletters2 %>% str_split(pattern = '\\+')
```

    ## [[1]]
    ## [1] "가" "나" "다" "라" "마" "바" "사"

`str_split` 함수 `pattern` 인자에 구분자를 할당할 때 `\\`를 추가한 것이 이상하죠? `pattern` 인자에는 **정규표현식(Regex)**이 할당되는데, 정규표현식에서 `+`는 '특정 문자를 하나 이상 무한대까지 찾기'라는 의미를 갖는 기호로 사용됩니다. 따라서 문자 그대로 `+`를 인식시키려면 **이스케이프 문자('\\')**를 `+` 앞에 추가해주어야 하는데요. R은 이스케이프 문자를 두 번 반복해주어야 합니다.

아무튼 구분자를 기준으로 여러 문자열이 잘 분리되었음을 확인할 수 있습니다. 이것은 R 기본함수인 `strsplit()`와 같은 결과를 갖습니다. 두 함수 모두 결과를 리스트로 반환하므로 만약 벡터로 결과를 변환하고 싶으면 코드 뒤에 파이프 연산자와 `unlist()` 함수를 추가하면 됩니다.

``` r
# strsplit() 함수로도 같은 결과를 얻을 수 있습니다. 
krletters2 %>% strsplit(split = '\\+')
```

    ## [[1]]
    ## [1] "가" "나" "다" "라" "마" "바" "사"

``` r
# unlist()를 사용하여 결과 객체를 벡터로 변환합니다. 
krletters2 %>% str_split(pattern = '\\+') %>% unlist()
```

    ## [1] "가" "나" "다" "라" "마" "바" "사"

### 문자열에서 시작 위치과 끝 위치를 지정하여 잘라내기

`str_sub()` 함수 `string` 인자에 문자열을 할당하고 `start` 인자에 시작 위치, `end` 인자에 끝 위치를 숫자로 할당한 후 실행하면 해당 부분의 문자열을 벡터로 출력합니다. 이것은 R 기본함수인 `substr()`과 같은 결과를 갖습니다.

``` r
# 샘플 문자열을 생성합니다. 
krAnthem <- '  동해물과 백두산이 마르고 닳도록   하느님이 보우하사 우리나라 만세  '

# 문자열에서 3번째부터 6번째 문자를 잘라냅니다. 
krAnthem %>% str_sub(start = 3, end = 6)
```

    ## [1] "동해물과"

``` r
substr(x = krAnthem, start = 3, stop = 6)
```

    ## [1] "동해물과"

### 문자열에서 앞뒤 공백 제거하기

`str_trim()` 함수 `string` 인자에 문자열을 할당하고 실행하면 문자열 앞뒤에 있는 공백을 제거하고 벡터로 출력합니다. 한편, `str_squich()` 함수를 실행하면 문자열 앞뒤 공백은 물론 문자열 안에서 반복되는 공백도 함께 제거합니다.

``` r
# 문자열 앞뒤에 있는 공백을 제거합니다. 
krAnthem %>% str_trim()
```

    ## [1] "동해물과 백두산이 마르고 닳도록   하느님이 보우하사 우리나라 만세"

``` r
# 문자열 앞뒤에 있는 공백과 문자열 안에서 중복되는 공백도 함께 제거합니다. 
krAnthem %>% str_squish()
```

    ## [1] "동해물과 백두산이 마르고 닳도록 하느님이 보우하사 우리나라 만세"

이상으로 **stringr** 패키지의 주요 함수를 이용하여 텍스트 처리하는 방법에 대해 살펴봤습니다.
