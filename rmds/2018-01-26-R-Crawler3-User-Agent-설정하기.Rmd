---
title: "R Crawler3 User-Agent 설정하기"
author: "Dr.Kevin"
date: "1/26/2018"
output: 
  md_document:
    variant: markdown_github
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, out.width = '750px', dpi = 300)
```

## 왜 User Agent를 설정해주어야 하나?

몇몇 웹사이트들은 User Agent(UA)를 보고 사람이 요청하는 것이 아니라고 판단되면 제대로 응답을 하지 않습니다. 이럴 때 UA를 설정해주는 것만으로도 간단하게 해결되는 경우가 있습니다.

크롬의 개발자도구에서 UA를 확인한 후 **GET** 함수나 **POST** 함수 인자로 추가 설정해주면 됩니다. 또는 [UserAgentString.com](http://useragentstring.com/)에서 손쉽게 확인할 수 있습니다. 

이번 예제에서는 네이버 부동산에서 제공되는 데이터를 수집하겠습니다. 패키지는 지난 번과 동일하게 불러오면 됩니다. 

```{r message=FALSE}
# 패키지 불러오기
library(httr)
library(rvest)
library(dplyr)
```

### 크롬 개발자도구에서 UA 확인하기

먼저 [네이버 부동산](http://land.naver.com/)으로 접속하고, 개발자도구의 네트워크 탭으로 이동합니다. 하단에 아무런 내용이 없다면 새로고침(F5) 합니다. 그러면 하단에 여러 항목들이 생길 것입니다. 

![](https://github.com/MrKevinNa/MrKevinNa.github.io/blob/master/images/Chrome_DevTools/Chrome%20Developer%20Tools%20Network%204.png?raw=true)

![](https://github.com/MrKevinNa/MrKevinNa.github.io/blob/master/images/Chrome_DevTools/Chrome%20Developer%20Tools%20Network%205.png?raw=true)

여기에서 가장 위에 위치한 **land.naver.com**을 클릭합니다. 그럼 오른쪽에 상세 내용이 보이는데 화면을 맨 아래로 이동하여 **Request Headers**의 **User-Agent**를 확인합니다. 바로 여기에서 보여지는 값이 이 컴퓨터로 접속할 때 서버로 전달되는 User Agent 입니다. 이 값을 복사하여 **httr** 패키지의 **user_agent()**의 인자로 할당합니다.

```{r}
# User Agent 지정
ua <- user_agent("Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36")
```

`GET()` 방식으로 웹 데이터를 수집하려면 URL을 잘 구성해야 합니다. 이번 예제에서는 "서울특별시 영등포구 여의도동"으로 구역을 지정하고 "아파트 매매 목록"을 확인해보겠습니다. 한 화면당 30개의 매물이 출력됩니다. 

지금 웹브라우저 주소창에 보이는 URL을 복사한 후 `GET()`을 이용하여 **HTML Request**를 해보겠습니다. 

```{r}
# url 지정
url <- "http://land.naver.com/article/articleList.nhn?rletTypeCd=A01&tradeTypeCd=A1&hscpTypeCd=A01%3AA03%3AA04&cortarNo=1156011000&articleOrderCode=&siteOrderCode=&cpId=&mapX=126.9310828&mapY=37.5213899&mapLevel=10&minPrc=&maxPrc=&minWrrnt=&maxWrrnt=&minLease=&maxLease=&minSpc=&maxSpc=&subDist=&mviDate=&hsehCnt=&rltrId=&mnex=&mHscpNo=&mPtpRange=&mnexOrder=&location=&ptpNo=&bssYm=&schlCd=&cmplYn="

# html request
resp <- GET(url)
status_code(resp)
```

상태코드가 "403"로 출력됩니다. 상태코드가 "4xx"인 것은 "요청 오류"를 의미하며 특히 "403"은 "인가 금지" 상태를 나타냅니다. 즉, 서버가 요청을 거부한 것이죠. 자세한 내용은 [HTML Response 상태코드](https://ko.wikipedia.org/wiki/HTTP_%EC%83%81%ED%83%9C_%EC%BD%94%EB%93%9C)에서 확인하시기 바랍니다. 

`GET()`에 `ua`를 추가한 후 다시 요청해보겠습니다. 

```{r}
# ua 추가해서 html request
resp <- GET(url, ua)
status_code(resp)
```

이제 상태코드가 "200"으로 정상입니다. 앞에서 말씀드린 바와 같이 User Agent를 추가해주는 것만으로도 이렇게 간단하게 해결하는 경우도 있습니다.

다행인 것은 관심 있는 데이터가 테이블 형태로 이루어져 있습니다. 따라서 예전에 배웠던 `html_table()`을 사용하면 간단하게 해결할 수 있습니다. 

크롬 개발자도구에 들어가서 해당 테이블 html tag를 찾아보니 `<table summary="확인매물 리스트" ...>`인 것으로 확인되었습니다. 그리고 table tag를 갖는 **HTML Element**가 딱 한 개입니다. 따라서 `html_node()`를 사용하겠습니다. 

```{r}
# 매물 리스트 수집하기
aptList <- read_html(resp) %>% 
  html_node(css = "table") %>% 
  html_table(fill = TRUE)
```

여기서 잠깐! **Windows** 사용자라면 이 부분에서 에러가 발생될 것입니다. 바로 인코딩 문제 때문인데요. 제가 이 부분을 해결하는 방법을 따로 정리했습니다. [인코딩 문제 해결하기](https://mrkevinna.github.io/%EC%9D%B8%EC%BD%94%EB%94%A9-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0%ED%95%98%EA%B8%B0/)를 먼저 확인하시기 바랍니다.

```{r}
# 데이터 테이블 구조 확인하기
str(object = aptList)

# 처음 10줄만 확인하기
head(x = aptList, n = 10)
```

웹페이지에 출력된 것은 총 30개였는데, 데이터 테이블로 정리된 `aptList`는 총 60줄입니다. 한 매물당 2줄씩 되어 있습니다. 특이한 것은 `html_table()`의 인자로 `fill = TRUE`를 추가해주었기 때문에 원래 `NA`인 칸에 특정 값이 반복해서 들어가 있는 것을 확인할 수 있습니다.

홀수 번째 행만 남기고 짝수 번째 행은 지우겠습니다.

```{r}
# 홀수 번째 행만 남기기
# 문자 벡터인 행번호를 숫자 벡터로 변환한 후 
# 2로 나누어서 나머지가 1인 행만 남기기 
aptList <- aptList[as.numeric(rownames(aptList)) %% 2 == 1, ]
```

그리고 불필요한 컬럼(`현장확인 사진`)과 문자열(`\n`, `\t`, `네이버부동산에서 보기`)을 삭제하겠습니다.

```{r}
# 4번째 컬럼 삭제
aptList <- aptList[, -4]

# 매물명 컬럼에서 "네이버부동산에서 보기" 지우기
aptList$매물명 <- str_replace_all(string = aptList$매물명, 
                               pattern = "[\n\t]+네이버부동산에서 보기",
                               replacement = "")
```

`면적(㎡)` 컬럼에도 불필요한 문자열(`\n`, `\t`, `공급면적`, `전용면적`)이 있습니다. 모두 지우고 공백을 구분자로 분리하겠습니다. 그리고 문자를 숫자로 변환하기 위해 `㎡`도 삭제합니다.

```{r}
# 불필요한 문자열 삭제
aptList$`면적(㎡)` <- str_replace_all(string = aptList$`면적(㎡)`, 
                                   pattern = "[\n\t]+|공급면적|전용면적|㎡",
                                   replacement = "")

# 공백을 구분자로 분리 (split)
str_split(string = aptList$`면적(㎡)`, pattern = " ")
```

`aptList` 객체의 `면적(㎡)` 컬럼 각 행이 길이가 3인 문자 벡터로 바뀌고 전체가 리스트 형태로 출력되었습니다. `str_split()`는 결과 객체를 리스트 형태로 반환합니다. 이 상태에서 각 행에서 맨 앞에 있는 데이터는 사용하지 않기로 합니다. 대신에 두 번째에 위치한 데이터를 추출하여 `공급면적`, 세 번째에 위치한 데이터는 `전용면적`이라는 컬럼명으로 하여 `aptList` 객체에 추가하겠습니다.

위와 같이 작업을 하려면 `sapply()`와 `[`에 대해서 알아야 합니다. `sapply()`는 벡터나 리스트를 받아서 같은 함수를 적용해주는 함수입니다. `lapply()`는 결과 객체를 리스트로 반환해주지만, `sapply()`는 좀 더 사용자 친화적인 함수로 `simplify = TRUE`를 추가하면 백터로 반환해줍니다. 그러니 별도로 `unlist()`를 사용할 필요가 없는 것입니다. 

`[`도 일종의 함수로 반복되는 객체들에 대해 같은 위치를 적용시키는 것입니다. 객체 인덱싱할 때 대괄호를 사용한다는 것을 떠올려보시기 바랍니다. 그리고 `[` 뒤에 오는 숫자는 참조할 위치를 나타냅니다. 즉, 리스트의 각 원소별로 두 번째에 있는 데이터를 가져오려면 아래와 같이 하면 됩니다. 

```{r}
# 공백을 구분자로 분리한 리스트의 두 번째 데이터만 가져오기
# apply 계열 함수는 주요 인자명이 대문자인 것에 주의! 
sapply(X = str_split(string = aptList$`면적(㎡)`, pattern = " "),
       FUN = "[", 2,
       simplify = TRUE)
```

이렇게 두 번째와 세 번째에 위치한 데이터를 각각 `aptList` 객체의 `공급면적`과 `전용면적` 컬럼으로 할당하려면 다음과 같이 합니다. 

```{r}
# 새로운 컬럼 생성하고 숫자 벡터로 변환하기
aptList$공급면적 <- sapply(X = str_split(string = aptList$`면적(㎡)`, pattern = " "),
                       FUN = "[", 2,
                       simplify = TRUE) %>% 
  as.numeric()

aptList$전용면적 <- sapply(X = str_split(string = aptList$`면적(㎡)`, pattern = " "),
                       FUN = "[", 3,
                       simplify = TRUE) %>% 
  as.numeric()

# 면적(㎡) 컬럼을 삭제하고, 첫 6행만 미리보기
aptList <- aptList[, -5]
head(aptList)
```

이번에는 `연락처` 컬럼을 정리해보겠습니다. 부동산과 전화번호가 복잡하게 붙어 있습니다. 먼저 불필요한 문자열(`\n`, `\t`, `부동산`, `공인중개사사무소`)을 지워보겠습니다.

```{r}
# 불필요한 문자열 삭제
aptList$연락처 <- str_replace_all(string = aptList$연락처, 
                               pattern = "[\n\t]+|부동산|공인중개사(사무소)*",
                               replacement = "")
```

이제 부동산 상호명과 전화번호를 분리하겠습니다. 부동산 상호명보다는 전화번호가 좀 더 규칙을 갖고 있으니 전화번호를 기준으로 분리하는 편이 낫습니다. 전화번호는 (예컨데 0505-1234-5678과 같은 번호도 있으니) 4자리가 숫자가 세번 반복되고 그 사이에 `-`이 있는 형태로 지정하면 될 것입니다. 문자열을 추출하는 함수는 `str_extract_all()`을 사용하면 됩니다. 

```{r}
# 연락처 컬럼에서 전화번호만 추출하여 전화번호 컬럼을 새로 만들기
# str_extract_all()은 리스트로 결과를 반환하므로 unlist() 추가!
aptList$전화번호 <- str_extract_all(string = aptList$연락처,
                                    pattern = "\\d{1,4}-\\d{1,4}-\\d{1,4}") %>% 
  unlist()

# 연락처 컬럼에서 전화번호에 해당하는 부분 삭제
# 일부 부동산 상호명과 전화번호 사이에 공백이 있으므로 str_trim() 추가!
aptList$연락처 <- str_replace_all(string = aptList$연락처, 
                               pattern = "\\d{1,4}-\\d{1,4}-\\d{1,4}",
                               replacement = "") %>% 
  str_trim()
```

마지막으로 `매물가(만원)` 컬럼에서 `comma(,)`를 삭제하고 문자를 숫자 벡터로 변환하겠습니다. 아울러 컬럼명도 `호가`로 변경합니다. 동시에 `연락처`를 `부동산`으로 함께 바꾸겠습니다. 

```{r}
# 매물가(만원) 컬럼에서 콤마(,)를 없애고 숫자 벡터로 변환하기
aptList$`매물가(만원)` <- str_replace_all(string = aptList$`매물가(만원)`, 
                                     pattern = ",",
                                     replacement = "") %>% 
  as.numeric()

# 컬럼명 바꾸기
colnames(aptList)[6:7] <- c("호가", "부동산")
```

앗! 컬럼이 뒤죽박죽 되어 있군요. 보기 좋게(?) 순서를 바꿔보도록 하겠습니다. 

```{r}
# 컬럼 순서 변경 (택1)
# 컬럼 위치를 지정하는 방법이 좀 더 간결하고
aptList <- aptList[, c(1:4, 8:9, 5:7, 10)]

# 컬럼명을 원하는 순서대로 기입할 수도 있습니다. 
aptList <- aptList[, c("거래", "종류", "확인일자", "매물명", "공급면적", 
                       "전용면적", "층", "호가", "부동산", "전화번호")]

# 처음 10행만 미리보기
head(x = aptList, n = 10L)
```

이상으로 웹사이트로부터 데이터를 수집하고 정리하는 과정을 소개해 드렸습니다. 웹크롤러를 만들어 데이터를 수집하고 데이터 분석을 위한 데이터 정제작업(영어로는 data wrangling)까지 상당한 시간과 노력이 소요됩니다. 따라서 이런 작업에 익숙해지도록 반복하여 훈련하시기 바랍니다.

다음에는 **자바스크립트**로 인해 원하는 HTML을 한 번에 가져오지 못하는 경우, 이를 해결하는 방법에 대해 소개하겠습니다.