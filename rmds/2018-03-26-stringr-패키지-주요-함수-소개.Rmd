---
title: "Stringr 패키지 주요 함수 소개"
author: "Dr.Kevin"
date: "3/26/2018"
output: 
  md_document:
    variant: markdown_github
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

데이터 전처리 과정에서 문자형 벡터 또는 문자열에서 원하는 텍스트를 찾고, 바꾸고, 합치고, 나누는 과정이 필요한 경우가 많습니다. 이번 포스팅에서는 텍스트를 원하는 방식으로 처리하는 함수들을 소개하고자 합니다. R 기본함수들로도 충분히 가능한 작업이지만 이번 포스팅에서는 **stringr**의 주요 함수들을 소개하려고 하는데요. 그 이유는 R 기본함수들로는 `파이프 연산자(%>%)`를 사용하지 못하는 경우가 많기 때문입니다. 파이프 연산자를 사용하면 코드를 깔끔하게 정리할 수 있고 가독성도 좋아집니다. 따라서 아래에 관련 함수에 대한 예제에서는 의도적으로 파이프 연산자를 사용하도록 하겠습니다. 

### 관심 있는 패턴 포함 여부 확인하기

`str_detect()` 함수 `string` 인자에 문자형 벡터를 할당하고 `pattern` 인자에 관심 있는 텍스트를 할당한 후 실행하면, 문자형 벡터의 각 원소 중 관심 있는 텍스트를 포함하면 `TRUE`, 그렇지 않으면 `FALSE`를 출력합니다. 만약 `string` 인자에 문자열을 할당하면, 해당 문자열에 관심 있는 텍스트가 포함되어 있는지를 `TRUE` 또는 `FALSE`로 출력합니다. 실습을 위해 샘플 문자형 벡터를 하나 생성한 뒤, `str_detect()` 함수를 실행합니다. 

```{r}
# 샘플 문자형 벡터를 생성합니다. 
subject <- c('국어', '영어', '수학', '과학', '국사', '도덕', '음악', '미술', '체육')

# 벡터에서 '어'를 포함하는 원소(과목명) 포함 여부를 확인합니다. 
subject %>% str_detect(pattern = '어')
```

전체 원소 중 '어'를 포함하고 있으면 `TRUE`, 없으면 `FALSE`로 출력된 것을 확인할 수있습니다. 이 코드 뒤에 `파이프 연산자(%>%)`와 `which()`를 추가하면 `TRUE`에 해당하는 원소의 위치를 숫자로 출력합니다. 이것은 R 기본 함수인 `grep()` 함수와 같은 결과를 갖습니다. 

```{r}
# 벡터에서 '어'를 포함하는 원소(과목명)의 위치를 숫자로 출력합니다.
subject %>% str_detect(pattern = '어') %>% which()
grep(pattern = '어', x = subject)
```

### 관심 있는 패턴 출력

`str_subset()` 함수 `string` 인자에 문자형 벡터를 할당하고 `pattern` 인자에 관심 있는 텍스트를 할당한 후 실행하면, 문자형 벡터에서 관심 있는 텍스트를 포함하는 원소만 출력합니다. `grep()` 함수에 `value = TRUE`를 추가하면 위치가 아닌 해당 원소값을 출력합니다. 

```{r}
# 벡터에서 '어'를 포함하는 원소(과목명)을 출력합니다.
subject %>% str_subset(pattern = '어')
grep(pattern = '어', x = subject, value = TRUE)
```

이번에는 관심 있는 텍스트를 찾는 다른 방법을 소개합니다. `str_extract()` 함수는 `string` 인자에 할당된 문자형 벡터의 각 원소에 대해서 관심 있는 텍스트가 있으면 정확히 그 패턴을, 없으면 `NA`를 출력합니다. 결과 객체는 벡터입니다. 

```{r}
# 샘플 문자형 벡터를 생성합니다. 
object <- c('요거트', '요요', '요리', '오리')

# 벡터의 각 원소에서 '요'를 포함하면 '요'를 출력합니다. 없으면 NA를 출력합니다. 
object %>% str_extract(pattern = '요')
```

그런데 주어진 문자형 벡터에서 두 번째 원소인 `요요`는 관심 있는 텍스트를 두 개 이상 가지고 있습니다. 이와 같이 관심 있는 텍스트가 2개 이상인 문자열에 대해서 모든 텍스트를 출력하고자 할 때 `str_extract_all()` 함수를 이용하면 됩니다. 다만 이 함수는 결과 객체를 리스트로 반환한다는 점에 주의해야 합니다. 

```{r}
# 벡터의 각 원소에서 '요'를 모두 찾아 출력합니다. 없으면 NA를 출력합니다. 
object %>% str_extract_all(pattern = '요')
```

실행 결과 리스트의 두 번째 원소가 `요`를 두 개 갖는 벡터인 것을 확인할 수 있습니다. 

### 관심 있는 패턴을 다른 패턴으로 바꾸기

`str_replace()` 함수 `string` 인자에 문자형 벡터, `pattern` 인자에 찾고자 하는 텍스트, `replacement` 인자에 바꿀 텍스트를 각각 할당한 후 실행하면, 문자형 벡터 각 원소에 대하여 찾고자 하는 텍스트를 바꿀 텍스트로 변경하여 벡터로 출력합니다. 

```{r}
# 벡터의 각 원소에 있는 '요'를 '유'로 바꿉니다. 
# '요'가 두 번 이상 있어도 맨 처음 '요'만 '유'로 바꿉니다. 
object %>% str_replace(pattern = '요', replacement = '유')
```

다만 이렇게 하면 찾고자 하는 텍스트가 여러번 반복될 때 맨 처음 텍스트만 바꿔줍니다. 만약 모든 텍스트를 다 바꿔주고 싶다면 `str_replace_all()` 함수를 사용하면 됩니다. 이것은 R 기본함수인 `gsub()`와 같은 결과를 갖습니다. 

```{r}
# 벡터의 각 원소에 있는 모든 '요'를 '유'로 바꿉니다. 
object %>% str_replace_all(pattern = '요', replacement = '유')
gsub(pattern = '요', replacement = '유', x = object)
```

### 여러 문자열을 (구분자를 추가하여) 하나의 문자열로 합치기 

`str_c()` 함수에 여러 문자열을 콤마(,)로 구분하여 할당한 후 실행하면, 여러 문자열이 하나의 커다란 문자열로 합쳐집니다. 이 함수의 `c`는 `combine` 또는 `concatenate`의 머릿글자로 이해하시면 됩니다. 

```{r}
# 여러 문자열을 하나의 문자열로 합칩니다.
str_c('가', '나', '다', '라', '마', '바', '사')
```

만약 문자열 사이에 특정 구분자(seperator)를 추가하려면, `str_c()` 함수에 `sep = '구분자'`를 추가하면 됩니다. 이것은 R 기본함수 `paste()`에 `sep = '구분자'`를 추가한 것과 같은 결과를 갖습니다. 

```{r}
# 여러 문자열에 구분자를 추가하여 하나의 문자열로 합칩니다.
str_c('가', '나', '다', '라', '마', '바', '사', sep = '+')
paste('가', '나', '다', '라', '마', '바', '사', sep = '+')
```

만약 `paste()`에 `sep` 인자를 추가하지 않고 실행하면 어떻게 될까요? 

```{r}
# paste 함수에 sep 인자를 추가하지 않고 실행하면 공백이 구분자로 추가됩니다. 
paste('가', '나', '다', '라', '마', '바', '사')
```

모든 문자열 사이에 공백이 하나씩 추가된 것을 알 수 있습니다. 즉, `paste()` 함수는 `sep = " "`이 기본값으로 설정되어 있습니다. 따라서 `str_c()`에 `sep`를 추가하지 않은 것과 동일한 결과를 얻으려면, `paste()` 함수에 `sep = ""`를 추가해주거나 아니면 `paste0()`를 사용하면 됩니다. 

```{r}
# paste 함수 sep 인자에 ''를 할당하고 실행하면
# 공백 없이 하나의 문자열로 합쳐집니다.
paste('가', '나', '다', '라', '마', '바', '사', sep = '')
paste0('가', '나', '다', '라', '마', '바', '사')
```

이번에는 `str_c()` 함수에 여러 문자열 대신 문자형 벡터를 할당하고 `sep = '  구분자'`를 추가한 후 실행해보겠습니다. 

```{r}
# str_c 함수에 문자형 벡터를 할당하고 실행하면 원하는 결과를 얻을 수 없습니다. 
krletters <- c('가', '나', '다', '라', '마', '바', '사')
krletters %>% str_c(sep = '+')
```

원래 문자형 벡터와 동일한 결과를 출력할 뿐, 하나의 문자열로 합쳐지지 않았습니다. 문자형 벡터의 각 원소를 하나의 커다란 문자열로 합치려면 `sep` 대신 `collapse` 인자를 사용하여야 합니다. 이것은 `paste()` 함수에도 동일하게 적용됩니다. 

```{r}
# 문자형 벡터의 각 원소를 하나의 커다란 문자열로 합칠 때에는
# collapse 인자를 사용합니다. 
krletters %>% str_c(collapse = '+')
paste(krletters, collapse = '+')
```

### 하나의 문자열을 구분자로 분리하기 

`str_split()` 함수 `string` 인자에 문자열을 할당하고 `pattern` 인자에 구분자를 할당한 후 실행하며, 문자열을 구분자 기준으로 나눈 후 리스트 객체를 반환합니다. 이것은 R 기본함수인 `strsplit()`와 동일한 결과를 갖습니다. 

```{r}
# 하나의 커다란 문자열을 생성합니다. 
krletters2 <- krletters %>% str_c(collapse = '+')

# 문자열을 구분자(+) 기준으로 분리합니다. 
krletters2 %>% str_split(pattern = '\\+')
```

`str_split` 함수 `pattern` 인자에 구분자를 할당할 때 `\\`를 추가한 것이 이상하죠? `pattern` 인자에는 **정규표현식(Regex)**이 할당되는데, 정규표현식에서 `+`는 '특정 문자를 하나 이상 무한대까지 찾기'라는 의미를 갖는 기호로 사용됩니다. 따라서 문자 그대로 `+`를 인식시키려면 **이스케이프 문자('\\')**를 `+` 앞에 추가해주어야 하는데요. R은 이스케이프 문자를 두 번 반복해주어야 합니다. 

아무튼 구분자를 기준으로 여러 문자열이 잘 분리되었음을 확인할 수 있습니다. 이것은 R 기본함수인 `strsplit()`와 같은 결과를 갖습니다. 두 함수 모두 결과를 리스트로 반환하므로 만약 벡터로 결과를 변환하고 싶으면 코드 뒤에 파이프 연산자와 `unlist()` 함수를 추가하면 됩니다. 


```{r}
# strsplit() 함수로도 같은 결과를 얻을 수 있습니다. 
krletters2 %>% strsplit(split = '\\+')

# unlist()를 사용하여 결과 객체를 벡터로 변환합니다. 
krletters2 %>% str_split(pattern = '\\+') %>% unlist()
```

### 문자열에서 시작 위치과 끝 위치를 지정하여 잘라내기

`str_sub()` 함수 `string` 인자에 문자열을 할당하고 `start` 인자에 시작 위치, `end` 인자에 끝 위치를 숫자로 할당한 후 실행하면 해당 부분의 문자열을 벡터로 출력합니다. 이것은 R 기본함수인 `substr()`과 같은 결과를 갖습니다. 

```{r}
# 샘플 문자열을 생성합니다. 
krAnthem <- '  동해물과 백두산이 마르고 닳도록   하느님이 보우하사 우리나라 만세  '

# 문자열에서 3번째부터 6번째 문자를 잘라냅니다. 
krAnthem %>% str_sub(start = 3, end = 6)
substr(x = krAnthem, start = 3, stop = 6)
```

### 문자열에서 앞뒤 공백 제거하기
`str_trim()` 함수 `string` 인자에 문자열을 할당하고 실행하면 문자열 앞뒤에 있는 공백을 제거하고 벡터로 출력합니다. 한편, `str_squich()` 함수를 실행하면 문자열 앞뒤 공백은 물론 문자열 안에서 반복되는 공백도 함께 제거합니다.  

```{r}
# 문자열 앞뒤에 있는 공백을 제거합니다. 
krAnthem %>% str_trim()

# 문자열 앞뒤에 있는 공백과 문자열 안에서 중복되는 공백도 함께 제거합니다. 
krAnthem %>% str_squish()
```

이상으로 **stringr** 패키지의 주요 함수를 이용하여 텍스트 처리하는 방법에 대해 살펴봤습니다.
